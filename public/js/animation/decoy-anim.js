// Generated by CoffeeScript 1.10.0
(function() {
  define(function(require) {
    var $, Backbone, Cell, DecoyAnim, PIXI, _, chroma, requestAnimationFrame;
    $ = require("jquery");
    _ = require("underscore");
    Backbone = require("backbone");
    PIXI = require("pixi");
    chroma = require("chroma-js");
    Cell = require("./cell");
    requestAnimationFrame = require("raf");
    DecoyAnim = {};
    DecoyAnim.initialize = function(options) {
      _.bindAll(this);
      this.$parent = this.$el;
      this.$parent.css('overflow', 'hidden');

      /*
      				OPTIONS
      				================
      				el              (jquery selector string|no default) must be defined in the options,
      												this is the parent container for the animation
      		squareSize      (int|20) - the pixel size of each square grid cell
      		baseColor       (string|'#67bfb6') - the base color of the screen
      		spawnRate       (int|3) - the number of frames before a cell spawn trigger
      		cellRate        (int|3) - the number of animating cells to spawn on the trigger
      		cellBrightness  (int|1) - this amount to brighten the animating cells from the base color
      		colorRange      (int|0.5) - the depth of variation in the random grid background
      		flashSpeedIn    (float|0.01) - incremental alpha change in the cell animation
      		flashSpeedOut   (float|0.02) - decremental alpha change in the cell animation
       */
      window.anim = this;
      this.squareSize = options.size || 20;
      this.baseColor = chroma(options.color || '#67bfb6');
      this.spawnRate = options.spawnRate || 3;
      this.cellRate = options.cellRate || 3;
      this.cellBrightness = options.cellBrightness || 1;
      this.colorRange = options.colorRange || 0.5;
      this.flashSpeedIn = options.flashSpeedIn || 0.01;
      this.flashSpeedOut = options.flashSpeedOut || 0.02;

      /*
      			stores the currently animating cells
       */
      this.cells = [];

      /*
      				used to count frames for cell spawning
       */
      this.frameCount = 0;

      /*
      				Used to pause hte animations
       */
      this.paused = false;

      /*
      			build the stage and setup of the pixi renderer
       */
      this.stage = new PIXI.Stage(0xFFFFFF, true);
      this.stage.interactive = true;
      this.graphics = new PIXI.Graphics();
      this.renderer = PIXI.autoDetectRenderer(this.$parent.width(), this.$parent.height(), null, true, true);
      this.renderer.view.id = "decoy-animation";
      this.$canvas = $('#' + this.renderer.view.id);
      this.resetAnimation();
      this.$parent.append(this.renderer.view);

      /*
      				kick off the animation loop
       */
      requestAnimationFrame(this.animate);

      /*
      				listen to resizing events
       */
      $(window).on('resize', _.throttle(this.resetAnimation, 200));
    };

    /*
    		Paints the random grid to the entire parent container
     */
    DecoyAnim.buildGrid = function() {
      var j, k, ref, ref1, x, y;
      for (x = j = 0, ref = this.count.x; 0 <= ref ? j <= ref : j >= ref; x = 0 <= ref ? ++j : --j) {
        for (y = k = 0, ref1 = this.count.y; 0 <= ref1 ? k <= ref1 : k >= ref1; y = 0 <= ref1 ? ++k : --k) {
          this.graphics.beginFill(parseInt('0x' + this.baseColor.darker(Math.random() * this.colorRange).hex().replace('#', '')));
          this.graphics.drawRect(this.squareSize * x, this.squareSize * y, this.squareSize, this.squareSize);
          this.graphics.endFill();
        }
      }
      this.stage.addChild(this.graphics);
    };

    /*
    	Animation loop updates cell animation rendering. Some garbage collection happens here.
    		When the cells are finished animating, the cell is pulled from the array, the backbone view
    		is destroyed, and the cell is nulled out.
     */
    DecoyAnim.animate = function() {
      var cell, deadcell, j, ref;
      this.checkMakeCell();
      this.renderer.render(this.stage);
      for (cell = j = ref = this.cells.length - 1; j >= 0; cell = j += -1) {
        this.cells[cell].update();
        if (this.cells[cell].dead) {
          deadcell = (this.cells.splice(cell, 1))[0];
          this.graphics.removeChild(deadcell.graphics);
          deadcell.close();
          deadcell = null;
        }
      }
      if (!this.paused) {
        requestAnimationFrame(this.animate);
      }
    };

    /*
    		Determine is cells should be spawn for this frame. If so, create the number of cells
    		specified in the cellRate options
     */
    DecoyAnim.checkMakeCell = function() {
      var i, j, ref;
      this.frameCount++;
      if (this.frameCount >= this.spawnRate) {
        this.frameCount = 0;
        for (i = j = 1, ref = this.cellRate; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
          this.makeCell();
        }
      }
    };

    /*
    		Creates an animating cells randomly on the grid and adds it to the array
     */
    DecoyAnim.makeCell = function() {
      var cell;
      cell = new Cell({
        x: Math.floor(Math.random() * this.count.x) * this.squareSize,
        y: Math.floor(Math.random() * this.count.y) * this.squareSize,
        size: this.squareSize,
        color: this.baseColor,
        brightness: this.cellBrightness,
        flashSpeedIn: this.flashSpeedIn,
        flashSpeedOut: this.flashSpeedOut
      });
      this.graphics.addChild(cell.graphics);
      cell.render();
      this.cells.push(cell);
    };

    /*
    		Pause the animation
     */
    DecoyAnim.pause = function() {
      this.paused = true;
    };

    /*
    	Play the animation
     */
    DecoyAnim.play = function() {
      this.paused = false;
      requestAnimationFrame(this.animate);
    };

    /*
    		sets all current cells to 'dead', which will remove them in the next animation frame
     */
    DecoyAnim.killAllCells = function() {
      var cell, j, ref;
      if (this.cells.length > 0) {
        for (cell = j = 0, ref = this.cells.length - 1; 0 <= ref ? j <= ref : j >= ref; cell = 0 <= ref ? ++j : --j) {
          this.cells[cell].dead = true;
        }
      }
    };

    /*
    		resets the canvas size and clears the grid. this happens on window resize, too
     */
    DecoyAnim.resetAnimation = function() {
      this.graphics.clear();
      this.killAllCells();

      /*
      				the number of cells to paint based on the parent container's size
       */
      this.count = {
        x: Math.ceil(this.$parent.width() / this.squareSize),
        y: Math.ceil(this.$parent.height() / this.squareSize)
      };

      /*
      			paint the random grid initially, once
       */
      this.buildGrid();
      this.renderer.resize(this.$parent.width(), this.$parent.height());
      this.$canvas.css('width', this.$parent.width());
      this.$canvas.css('height', this.$parent.height());
      this.renderer.view.style.display = "block";
      this.renderer.view.style.position = "absolute";
      this.renderer.view.style.top = 0;
      this.renderer.view.style.bottom = 0;
      this.renderer.view.style.left = 0;
      this.renderer.view.style.right = 0;
    };
    return Backbone.View.extend(DecoyAnim);
  });

}).call(this);
